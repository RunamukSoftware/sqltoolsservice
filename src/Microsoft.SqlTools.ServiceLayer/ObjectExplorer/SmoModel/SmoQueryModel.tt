<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
// This file was generated by a T4 Template. Do not modify directly, instead update the SmoQueryModelDefinition.xml file
// and re-run the T4 template. This can be done in Visual Studio by right-click in and choosing "Run Custom Tool",
// or from the command-line on any platform by running "build.cmd -Target=CodeGen" or "build.sh -Target=CodeGen".

using System;
using System.Collections.Generic;
using System.Composition;
using System.Linq;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Sdk.Sfc;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Broker;

namespace Microsoft.SqlTools.ServiceLayer.ObjectExplorer.SmoModel
{
<#
	var directory = Path.GetDirectoryName(Host.TemplateFile);
	string xmlFile = Path.Combine(directory, "SmoQueryModelDefinition.xml");
    
	/////////
	// Now generate all the Query methods
	/////////
	var allNodes = GetNodes(xmlFile);
	var indent = "    ";
	foreach (var nodeName in allNodes)
	{
		XmlElement nodeElement = GetNodeElement(xmlFile, nodeName);
		IList<string> parents = GetParents(nodeElement, xmlFile, nodeName);
		string nodeType = GetNodeType(nodeElement, nodeName);

		string queryBaseClass = "SmoQuerier";
		PushIndent(indent);
		WriteLine("");
		WriteLine(string.Format("[Export(typeof({0}))]", queryBaseClass));
		WriteLine(string.Format("internal partial class {0}Querier: {1}", nodeName, queryBaseClass));
		WriteLine("{");
		PushIndent(indent);

		// Supported Types
		WriteLine("Type[] supportedTypes = new Type[] { typeof("+ nodeType + ") };");
		WriteLine("");
		WriteLine("public override Type[] SupportedObjectTypes { get { return supportedTypes; } }");
		WriteLine("");

		// Query impl
 		WriteLine("public override  IEnumerable<SqlSmoObject> Query(SmoQueryContext context, string filter)");
		WriteLine("{");
		PushIndent(indent);

		// TODO Allow override of the navigation path
		foreach(var parentType in parents)
		{
			string parentVar = string.Format("parent{0}", parentType);
			WriteLine(string.Format("{0} {1} = context.Parent as {0};", parentType, parentVar));
			WriteLine(string.Format("if ({0} != null)", parentVar));
			WriteLine("{");
			PushIndent(indent);
			WriteLine("bool hasFilter = !string.IsNullOrEmpty(filter);");
			
			string navigationPath = GetNavigationPath(nodeElement, xmlFile, nodeName, parentType);
			WriteLine(string.Format("var retValue = {0}.{1};", parentVar, navigationPath));
			WriteLine("if (retValue != null)");
			WriteLine("{");
			PushIndent(indent);
			
			
			if (IsCollection(nodeElement))
			{
				string fieldForUrn = GetNavPathFieldForUrn(xmlFile, nodeName, parentType);
				if (!string.IsNullOrEmpty(fieldForUrn))
				{
					fieldForUrn = string.Format("{0}.{1}", parentVar, fieldForUrn);
				}
				else
				{
					fieldForUrn = parentVar;
				}
				WriteLine("HashSet<string> urns = null;");
				
				WriteLine("if (hasFilter)");
				WriteLine("{");
				PushIndent(indent);
				WriteLine(string.Format("string urn = $\"{{{0}.Urn.ToString()}}/{1}\" + filter;", fieldForUrn, nodeType));
				WriteLine("Enumerator en = new Enumerator();");
				WriteLine("Request request = new Request(new Urn(urn));");
				WriteLine("ServerConnection serverConnection = new ServerConnection(context.Server.ConnectionContext.SqlConnectionObject);");
				WriteLine("EnumResult result = en.Process(serverConnection, request);");
				WriteLine("urns = GetUrns(result);");
				PopIndent();
				WriteLine("}");
				WriteLine("if (hasFilter && urns != null)");
				WriteLine("{");
				PushIndent(indent);
				WriteLine(string.Format("return new SmoCollectionWrapper<{0}>(retValue).Where(c => PassesFinalFilters({1}, c) && urns.Contains(c.Urn));", nodeType, parentVar));
				PopIndent();
				WriteLine("}");
				WriteLine("else");
				WriteLine("{");
				PushIndent(indent);
				WriteLine(string.Format("return new SmoCollectionWrapper<{0}>(retValue);", nodeType));
				PopIndent();
				WriteLine("}");
			}
			else
			{
				WriteLine("return new SqlSmoObject[] { retValue };");
			}
			
			PopIndent();
			WriteLine("}");
			PopIndent();
			WriteLine("}");	// close If
		}

		WriteLine("return Enumerable.Empty<SqlSmoObject>();");

		PopIndent();
		WriteLine("}");	// close Query method
		PopIndent();
		WriteLine("}"); // close Class
		PopIndent();
	}
#>
}

<#+

	public static string[] GetNodes(string xmlFile)
	{
		List<string> typesList = new List<string>();
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		XmlNodeList treeTypes = doc.SelectNodes("/SmoQueryModel/Node");
		if (treeTypes != null)
		{
			foreach (var type in treeTypes)
			{
				XmlElement element = type as XmlElement;
				if (element != null)
				{
					typesList.Add(element.GetAttribute("Name"));
				}
			}
		}
		return typesList.ToArray();
	}
    
	public static XmlElement GetNodeElement(string xmlFile, string nodeName)
	{
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		return (XmlElement)doc.SelectSingleNode(string.Format("/SmoQueryModel/Node[@Name='{0}']", nodeName));
	}

	public static string GetNavPathField(string xmlFile, string nodeName, string parent)
	{
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		XmlElement navPathElement = (XmlElement)doc.SelectSingleNode(string.Format("/SmoQueryModel/Node[@Name='{0}']/NavigationPath[@Parent='{1}']", nodeName, parent));
		
		return navPathElement == null ? null : navPathElement.GetAttribute("Field");
	}

	public static string GetNavPathFieldForUrn(string xmlFile, string nodeName, string parent)
	{
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		XmlElement navPathElement = (XmlElement)doc.SelectSingleNode(string.Format("/SmoQueryModel/Node[@Name='{0}']/NavigationPath[@Parent='{1}']", nodeName, parent));
		
		return navPathElement == null ? null : navPathElement.GetAttribute("FieldForUrn");
	}

	public static string GetNavigationPath(XmlElement nodeElement, string xmlFile, string nodeName, string parentName)
	{
		string navPathField = GetNavPathField(xmlFile, nodeName, parentName);
		if (!string.IsNullOrEmpty(navPathField))
		{
			return navPathField;
		}
		// else use pluralized type as this is the most common scenario
		string nodeType = GetNodeType(nodeElement, nodeName);

		string nodeTypeAccessor = IsCollection(nodeElement) ? string.Format("{0}s", nodeType) : nodeType;
		return nodeTypeAccessor;
	}
	
	public static string GetNodeType(XmlElement nodeElement, string nodeName)
	{
		var type = nodeElement.GetAttribute("Type");
		if (!string.IsNullOrEmpty(type))
		{
			return type;
		}
		// Otherwise assume the type is the node name without "Sql" at the start
		var prefix = "Sql";
		return nodeName.IndexOf(prefix) == 0 ? nodeName.Substring(prefix.Length) : nodeName;
	}
	
	public static bool IsCollection(XmlElement nodeElement)
	{
		var collection = nodeElement.GetAttribute("Collection");
		bool result;
		if (bool.TryParse(collection, out result))
		{
			return result;
		}
		// Default is true
		return true;
	}

	public static IList<string> GetParents(XmlElement nodeElement, string xmlFile, string parentName)
	{
		var parentAttr = nodeElement.GetAttribute("Parent");
		if (!string.IsNullOrEmpty(parentAttr))
		{
			return new string[] { parentAttr };
		}
		
		var parentNodes = GetChildren(xmlFile, parentName, "Parent");
		if (parentNodes != null && parentNodes.Count > 0)
		{
			List<string> parents = new List<string>();
			foreach(var node in parentNodes)
			{
				parents.Add(node.InnerText);
			}
			return parents;
		}
		
		// default to assuming a type is under Database
		return new string[] { "Database" };
	}
	
	public static List<XmlElement> GetChildren(string xmlFile, string parentName, string childNode)
	{
		XmlElement nodeElement = GetNodeElement(xmlFile, parentName);
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);

		List<XmlElement> retElements = new List<XmlElement>();
		XmlNodeList nodeList = doc.SelectNodes(string.Format("/SmoQueryModel/Node[@Name='{0}']/{1}", parentName, childNode));
		foreach (var item in nodeList)
		{
		   XmlElement itemAsElement = item as XmlElement;
		   if (itemAsElement != null)
		   {
		      retElements.Add(itemAsElement);
		   }
		}
		return retElements;
	}

#>